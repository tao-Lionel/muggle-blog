---
title: 第十章 函数
date: 2022-09-22 18:53:58
permalink: /pages/f875f6/
categories:
  - 前端
  - 学习笔记
  - 《JavaScript高级程序设计》笔记
tags:
  -
author:
  name: Lionel tao
  link: https://github.com/tao-Lionel
---

## 10.1 箭头函数

<mark>箭头函数不能使用 arguments、super 和 new.target,也不能用作构造函数,箭头函数也没有 prototype 属性</mark>

## 10.2 函数名

函数名就是指向函数的指针，所以一个函数可以有多个函数名。

```js
function sum(num1, num2) {
  return num1 + num2;
}
let sum1 = sum; // 用不带括号的函数名访问函数只会访问函数指针
sum1(10, 10); // 20

sum = null; //把函数名赋值null,就切断了他与函数之间关系
sum1(10, 10); // 20
```

## 10.3 理解参数

函数不关心传入的参数，是因为在函数的参数在内部表现为一个数组
不是箭头函数的函数可以在内部访问 arguments 对象

```js
function sum() {
  console.log(arguments[0], arguments[1], arguments.length);
}
```

ES 中所有的参数都是按值传递的，如果把对象作为参数传递，那么传递的值就是这个对象的引用

## 10.4 没有重载

如果定义两个同名的函数，后定义的会覆盖前面定义的，可以通过检查参数的类型和数量来执行不同的逻辑，已实现函数重载

## 10.5 默认参数值

**默认参数作用域与暂时性死区**

给多个参数定义默认值实际上跟使用 let 关键字声明变量一样
参数初始化顺序遵循`暂时性死区`规则，即前面定义的参数不能引用后面定义的，参数也存在自己的作用域内，他们不能引用函数体的作用域。

## 10.6 参数扩展与收集

### 10.6.1 扩展参数

```js
function sum() {
  console.log(arguments.length); // 3
}
let arr = [1, 2, 3];
fun(arr);
```

### 10.6.2 收集参数

扩展操作符可以把剩余的参数收集起来

```js
function sum(a, ...val) {
  console.log(val);
}
sum(1, 2, 3); // [2,3]
```

## 10.7 函数声明与函数表达式

`函数声明提升`: 函数声明会在任何代码执行之前先被读取并添加到执行上下文

注意：函数表达式不存在提升，不管是`let`还是`var`

## 10.8 函数作为值

函数可以作为参数传递

## 10.9 函数内部

### 10.9.1 arguments

arguments 是一个类数组对象，这个对象只有以`function`关键字定义函数时才会有

arguments 对象还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针

```js
function fun(num) {
  if (num <= 1) {
    return 1;
  } else {
    // num * fun(num - 1)
    return num * arguments.callee(num - 1);
  }
}
```

### 10.9.2 this

在标准函数中，谁调用函数，this 就指向谁

```js
window.color = "red";
let o = {
  color: "blue",
};

function sayColor() {
  console.log(this.color);
}

sayColor(); // red

o.sayColor = sayColor;
o.sayColor(); // blue
```

在箭头函数中，this 引用的是`定义箭头函数`的上下文

```js
window.color = "red";
let o = {
  color: "blue",
};

let sayColor = () => {
  console.log(this.color);
};

sayColor(); // red

o.sayColor = sayColor;
// sayColor中的this始终指向window
o.sayColor(); // red
```

注意：函数名只是保存指针的变量，因此定义在全局的 sayColor()函数和 o.sayColor()是同一个函数，只不过执行的上下文不一样

### 10.9.3 caller
