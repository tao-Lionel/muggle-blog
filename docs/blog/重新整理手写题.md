## 手写instanceof
原理：
`instanceof`用来检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上（[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)）
（就是能在对象的原型链中能找到构造函数的`prototype`）
```javascript
function myInstanceof(left, right) {
  if (typeof left !== "object") {
    return false;
  }

  while (true) {
    if (left === null) {
      // 说明原型链已经找完了
      return false;
    }

    if (left.__proto__ === right.prototype) {
      return true;
    }

    left = left.__proto__;
  }
}

// 测试效果
function F() {}
let f = new F();
console.log(myInstanceof(f, F)); // true
console.log(f instanceof F); // true

console.log(myInstanceof({}, Object)); // true
console.log({} instanceof Object); // true

console.log(myInstanceof(1, Number)); // false
console.log(1 instanceof Number); // false

console.log(myInstanceof(null, Object)); // false
console.log(null instanceof Object); // false
```

## 手写防抖
防抖：指的是规定时间内多次调用函数，函数只执行一次
例如：搜索框只有在用户输入完成才去请求接口查询
```javascript
function debounce(fn, wait = 300) {
  let timer = null;
  // 采用闭包的形式，否则每次触发时都会重新创建一个新的同名变量
  return function () {
    // 清掉上次一的定时器
    if (timer) clearTimeout(timer);
    // 返回一个新的定时器
    timer = setTimeout(() => {
      fn.apply(this, [...arguments]);
    }, wait);
  };
}
```

## 手写节流
节流：短时间的额多次执行，变为几次执行
例如：滚动监听
```javascript
// 创建一个变量保存上一次触发的时间
// 触发的时候记录当前触发的时间 判断当前触发的时间减去上次触发的时间是否大于规定的时间， 如果是则执行，并且更新上一次触发的时间
function throttle(fn, wait = 1000) {
  // 通过闭包保存上一次触发的时间
  let p = 0;
  return function () {
    // 触发的时间
    let now = +new Date();
    // 如果触发的时间减去上一次触发的时间 大于 间隔的时间
    if (now - p > wait) {
      fn.apply(this, [...arguments]);
      // 更新上一次触发的时间
      p = now;
    }
  };
}

```
另一中写法同样可以达到节流的效果
```javascript
function throttle(fn,wait =1000){
  // 通过闭包保存一个标记
  let time = null
  return function(){
    // 如果标记有值就返回
    if(time) return 
    
    fn.apply(this,[...arguments])
    // 更新标记
    time = setTimeout(()=>{
      time = null
    },wait)
  }
}
```
## 手写call
首先我们先明确`call`的使用方法，它主要是显式的改变函数的`this`
`call(thisArg, arg, arg1, arg2,...)`
```javascript
Function.prototype.MyCall = function (context, ...arg) {
  // 调用者必须是函数
  if (typeof this !== "function") {
    throw "this 必须是函数";
  }

  // 没有指定上下文，默认指向全局
  if (context === undefined || context === null) {
    context = window;
  } else {
    // context 是原始值的，this会指向他的实例对象
    context = Object(context);
  }

  let fn = Symbol("fn");

  // 将调用call的函数绑定到新的属性上，通过改变函数的调用者来改变this指向
  context[fn] = this;

  // 执行方法并传入参数，并收集返回值
  const res = context[fn](...arg);

  // 删除属性
  delete context[fn];

  return res;
};
```
## 手写apply
`apply` 基本和`call`是一样的，只是传参不一样
`apply(thisArg, [arg1, arg2, arg3])`
```javascript
Function.prototype.myApply = function (context) {
  if (typeof this !== "function") {
    throw "调用者必须是函数";
  }

  if (context === undefined || context === null) {
    context = window;
  } else {
    context = Object(context);
  }

  const fn = Symbol("fn");

  context[fn] = this;

  let arg = arguments[1];
  let res;
  if (arg) {
    res = context[fn](...arg);
  } else {
    res = context[fn]();
  }

  delete context[fn];

  return res;
};
```
## 手写bind
`bind`创建一个新的函数，当调用这个新函数时，它会调用原始函数并将this指定为给定的值，同时还支持传入参数，这些参数会插入在调用新函数传入的参数的前面
`bind(thisArgs, arg1, arg2,...)`
```javascript
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw "调用者必须是函数";
  }

  let args = [...arguments].slice(1);
  // 保存原始函数的引用
  let self = this;

  let fn = function (...innerArgs) {
    if (this instanceof fn) {
      // 说明返回出去的函数被new了
      return new self(...args, ...innerArgs);
    }

    // 使用apply改变原始函数的this
    return self.apply(context, args.concat(innerArgs));
  };

  return fn;
};
```
## 手写new
`new` 的过程

1. 创建一个新的对象
2. 新对象的`__proto__`指向构造函数的`prototype`
3. 改变构造函数的this指向新创建的对象 并执行
4. 返回这个新创建的对象
```javascript
function myNew() {
  // 1. 创建一个空对象
  let obj = {};
  // 获取构造函数(第一个参数就是构造函数)
  const constructor = [].shift.call(arguments);
  // 2. 新对象的原型 指向构造函数的原型
  obj.__proto__ = constructor.prototype;

  // 3. 改变构造函数的this
  let res = co.apply(obj, ...arguments);

  // 4.如果构造函数返回了一个对象 那就返回这个对象 否则返回新创建的对象
  return res instanceof Object ? res : obj;
}
```
## setTimeout实现setInterval
```javascript
// 变量用来存放定时器编号
let times = [];

// setTimeout 实现 setInterval
function bar(time) {
  console.log("setTimeout 实现setInterval", time);
  // 保存定时器编号
  times.push(
    setTimeout(() => {
      bar(time);
    }, time)
  );
}

// 清除定时器
function clear() {
  // 循环清除定时器
  for (let item of times) {
    console.log(item);
    clearTimeout(item);
  }
}

setTimeout(() => {
  bar(1000);
}, 1000);

// 五秒后清除
setTimeout(clear, 5000);
```
## 手写简化版Promise
```javascript
// promise 有三种状态：pending、resolve、rejected
// promise 的状态只能从pending变为resolve 或者 从pending 变为 rejected
// promise 的状态一旦改变就不会在变，永远都是这个状态
// 一旦新建promise 就会立即执行

// 定义 promise 的三种状态
const PENDING = "pending";
const REJECTED = "rejected";
const RESOLVE = "resolve";

class myPromise {
  constructor(fn) {
    // 初始状态是pending
    this.status = PENDING;
    // 成功后的值
    this.value = undefined;
    // 失败后的原因
    this.reason = undefined;
    // 定义两个容器存放对应的回调 用来解决异步调用resolve和reject
    this.resolveList = [];
    this.rejectList = [];

    // 成功的回调
    const resolve = (value) => {
      // 状态只能从pending变为resolve
      if (this.status === PENDING) {
        this.status = RESOLVE;
        // 保存传入的参数
        this.value = value;

        // 从容器中取出success
        this.resolveList.map((fn) => fn(this.value));
      }
    };

    // 失败的回调
    const reject = (reason) => {
      // 状态只能从pending变为reject
      if (this.status === PENDING) {
        this.status = REJECTED;
        // 保存失败的原因
        this.reason = reason;

        // 从容器中取出error
        this.rejectList.map((fn) => fn(this.reason));
      }
    };

    // 执行传入的方法
    // 如果传入的方法报错的话就改变promise状态
    try {
      fn(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }

  // 实现then 接受两个方法作为参数，都是可选的
  then(success, error) {
    success = typeof success === "function" ? success : (v) => v;
    error =
      typeof error === "function"
      ? error
      : (e) => {
        throw e;
      };

    // 成功
    if (this.status === RESOLVE) {
      success(this.value);
    }

    // 失败
    if (this.status === REJECTED) {
      error(this.reason);
    }

    // 状态是pending 时 存放success 和 error
    if (this.status === PENDING) {
      this.resolveList.push(success);
      this.rejectList.push(error);
    }
  }

  // 实现catch
  catch(error) {
    this.then(null, error);
  }

  // 实现finally 可以用then来实现， 不管成功失败都会执行
  finally(fn) {
    this.then(
      (v) => {
        fn();
        return v;
      },
      (e) => {
        fn();
        throw e;
      }
    );
  }
}
```
## 手写简易深拷贝
```javascript
// 判断是否是对象
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}

// 简易深拷贝
function deepClone(target) {
  if (!target) return target;

  // 如果是数组就初始化数组否则就是对象
  const res = Array.isArray(target) ? [] : {};

  // 循环遍历每一项 给新对象赋值
  for (const key in target) {
    let value = target[key];
    // 如果属性的值还是对象就 就递归，否则直接赋值给新对象的属性
    res[key] = isObject(value) ? deepClone(value) : value;
  }

  return res;
}
```
## 实现getqueryString
给定一段url参数和参数名称，返回该参数的值
```javascript
let url = "https://www.baidu.com/s?id=123&name=why&phone=13876769797";
function getQueryString(name) {
  const index = url.indexOf("?");
  if (index === -1) {
    return undefined;
  }
  let queryArr = url.substring(index + 1).split("&");
  for (const item of queryArr) {
    const p = item.split("=");
    if (p[0] === name) {
      return p[1];
    }
  }
}
```
