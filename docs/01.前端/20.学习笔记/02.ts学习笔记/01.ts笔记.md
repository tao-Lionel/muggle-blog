---
title: ts笔记
date: 2022-12-02 14:45:46
permalink: /pages/b3b2b6/
categories:
  - 前端
  - 学习笔记
  - ts学习笔记
tags:
  -
author:
  name: Lionel tao
  link: https://github.com/tao-Lionel
---

## 原始数据类型

原始数据类型包括：布尔值、数值、字符串、null、undefined、Symbol、ES10 新类型 BigInt

### 布尔值

使用`boolean`定义布尔值类型

```ts
let isDone: boolean = false;
```

### 数值

使用`number`定义数值类型

```ts
let d: number = 5;
```

### 字符串

使用`string`定义字符串类型

```ts
let mName: string = "Tom";
```

### 空值

JavaScript 没有空值（void）的概念，在 Ts 中可以用`void`表示没有任何返回值的函数

```ts
function fn(): void {
  console.log("xx");
}
```

### Null 和 Undefined

可以使用`null`和`undefined`来定义这两个原始数据类型

```ts
let u: undefined = undefined;
let n: null = null;
```

与`void`的区别就是`undefined`和`null`是所有类型的子类型，也就是说 null 和 undefined 类型的变量，可以赋值给其他类型的变量

```ts
let num: number = undefined;
```

而`void`类型的变量不能赋值给其他类型的变量

## 任意值

`any`用来表示允许赋值为任意类型

变量在声明的时候，未指定其类型，会被识别为任意值类型。

## 类型推论

如果没有明确的指定类型，那么 ts 会按照类型推论的规则推断出一个类型。

```ts
let s = "abc";
s = 7;
// 报错
```

## 联合类型

表示取值可以为多种类型中的一种
用 | 分隔每个类型

```ts
let t: string | number;
t = "abc";
t = 5;

t = true; // 报错
```

### 访问联合类型的属性或方法

当 ts 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法

```ts
function fn(t: string | number) {
  return t.length; // 报错
  t.toString(); // 不报错
}
```

联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型

```ts
let a: string | number;
a = "abc";
console.log(a.length); // 3
a = 7;
console.log(a.length); // 报错
```

## 对象的类型--接口

使用接口（interfaces）来定义对象的类型

在面向对象的语言中，接口（interfaces）是一个很重要的概念，他是对行为的抽象，而具体如何行动需要有类（classes）去实现（implement）

ts 中的接口除了可用于对类的一部分行为进行抽象以外，也常用于对 对象的形状（shape）进行描述

```ts
// 可以用?来定义可选属性
interface Person {
  name: string;
  age: number;
  sex?: string;
}

// 少属性多属性都是会报错的
let tom: Person = {
  name: "tom",
  age: 25,
};
```

### 任意属性

如果希望一个接口允许有任意的属性

```ts
interface Person {
  name: string;
  age?: number;
  [propName: string]: any;
}

let tom: Person = {
  name: "tom",
  gender: "male",
};
```

使用`[propName:string]`定义了任意属性取`string`类型的值

**一但定义了任意属性,那么确定属性和可选属性的类型都必须是它的类型的子集**

```ts
interface Person {
  name: string;
  age?: number;
  [propName: string]: string;
}

let tom: Person = {
  name: 2, // 报错 类型应是number
  gender: 1, // 报错
};
```

一个接口中只能定义一个任意属性，如果接口中有多个类型的属性，则可以在任意属性中使用联合类型。

```ts
interface Person {
  name: string;
  age?: number;
  [propName: string]: string | number;
}

let tom: Person = {
  name: 2,
  gender: "abc",
};
```

### 只读属性

有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用`readonly`定义只读属性

```ts
interface Person {
  readonly id: number;
  name: string;
  age?: number;
  [propName: string]: any;
}

let tom: Person = {
  id: 123,
  name: "tom",
  gender: "male",
};

tom.id = 111; // 报错
```

`❗注意：`只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。

## 数组的类型

### 【类型 + 方括号】表示法

```ts
let f: number[] = [1, 2, 2, 3, 4];

let f: number[] = [1, 2, 3, 4, "5"]; // 报错
```

数组的一些方法参数也会根据数组在定义是约定的类型进行限制

```ts
let f: number[] = [1, 2, 3, 4];
f.push("2"); // 报错
```

### 数组泛型

也可以用数组泛型（Array Generic）`Array<elemType>`来表示数组

```ts
let arr: Array<number> = [1, 2, 3];
```

### 用接口表示数组

```ts
interface NumberArray {
  [index: number]: number;
}

// NumberArray 表示只要索引的类型是数字时，那么值的类型必须是数字
let f: NumberArray = [1, 2, 3, 4];
```

### 类数组

类数组（Array-like Object）不是数组类型，比如`arguments`

```ts
function fn() {
  let args: number[] = arguments;
}
// 报错 因为arguments 是一个类数组，不能用普通数组的方式来描述，应该用接口
```

```ts
function fn() {
  let args: {
    [index: number]: number;
    length: number;
    callee: Function;
  } = arguments;
}
```

常用的类数组都有自己的接口定义，js 中有内置对象可以在 ts 中当做定义好的类型

## 函数的类型

### 函数声明
