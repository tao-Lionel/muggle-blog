---
title: 第十章 函数
date: 2022-09-22 18:53:58
permalink: /pages/f875f6/
categories:
  - 前端
  - 学习笔记
  - 《JavaScript高级程序设计》笔记
tags:
  -
author:
  name: Lionel tao
  link: https://github.com/tao-Lionel
---

## 10.1 箭头函数

<mark>箭头函数不能使用 arguments、super 和 new.target,也不能用作构造函数,箭头函数也没有 prototype 属性</mark>

## 10.2 函数名

函数名就是指向函数的指针，所以一个函数可以有多个函数名。

```js
function sum(num1, num2) {
  return num1 + num2;
}
let sum1 = sum; // 用不带括号的函数名访问函数只会访问函数指针
sum1(10, 10); // 20

sum = null; //把函数名赋值null,就切断了他与函数之间关系
sum1(10, 10); // 20
```

## 10.3 理解参数

函数不关心传入的参数，是因为在函数的参数在内部表现为一个数组
不是箭头函数的函数可以在内部访问 arguments 对象

```js
function sum() {
  console.log(arguments[0], arguments[1], arguments.length);
}
```

ES 中所有的参数都是按值传递的，如果把对象作为参数传递，那么传递的值就是这个对象的引用

## 10.4 没有重载

如果定义两个同名的函数，后定义的会覆盖前面定义的，可以通过检查参数的类型和数量来执行不同的逻辑，已实现函数重载

## 10.5 默认参数值

**默认参数作用域与暂时性死区**

给多个参数定义默认值实际上跟使用 let 关键字声明变量一样
参数初始化顺序遵循`暂时性死区`规则，即前面定义的参数不能引用后面定义的，参数也存在自己的作用域内，他们不能引用函数体的作用域。

## 10.6 参数扩展与收集

### 10.6.1 扩展参数

```js
function sum() {
  console.log(arguments.length); // 3
}
let arr = [1, 2, 3];
fun(arr);
```

### 10.6.2 收集参数

扩展操作符可以把剩余的参数收集起来

```js
function sum(a, ...val) {
  console.log(val);
}
sum(1, 2, 3); // [2,3]
```

## 10.7 函数声明与函数表达式

`函数声明提升`: 函数声明会在任何代码执行之前先被读取并添加到执行上下文

注意：函数表达式不存在提升，不管是`let`还是`var`

## 10.8 函数作为值

函数可以作为参数传递

## 10.9 函数内部

### 10.9.1 arguments

arguments 是一个类数组对象，这个对象只有以`function`关键字定义函数时才会有

arguments 对象还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针

```js
function fun(num) {
  if (num <= 1) {
    return 1;
  } else {
    // num * fun(num - 1)
    return num * arguments.callee(num - 1);
  }
}
```

### 10.9.2 this

在标准函数中，谁调用函数，this 就指向谁

```js
window.color = "red";
let o = {
  color: "blue",
};

function sayColor() {
  console.log(this.color);
}

sayColor(); // red

o.sayColor = sayColor;
o.sayColor(); // blue
```

在箭头函数中，this 引用的是`定义箭头函数`的上下文

```js
window.color = "red";
let o = {
  color: "blue",
};

let sayColor = () => {
  console.log(this.color);
};

sayColor(); // red

o.sayColor = sayColor;
// sayColor中的this始终指向window
o.sayColor(); // red
```

注意：函数名只是保存指针的变量，因此定义在全局的 sayColor()函数和 o.sayColor()是同一个函数，只不过执行的上下文不一样

### 10.9.3 caller

这个属性引用的是调用当前函数的函数

### 10.9.4 new.target

检测函数是否使用 new 关键字调用的 new.target 属性

```js
function king() {
  if (!new.target) {
    throw "xxxxxx";
  }
  console.log("aaaaa");
}
new king(); // aaaaa
king(); // xxxxxx
```

## 10.10 函数属性与方法

函数是对象，因此有属性和方法。

函数还有两个方法：apply()和 call()

```js
function sum(num1, num2) {
  return num1 + num2;
}

function callSum1(num1, num2) {
  // this 是window  因为是在全局作用域中调用的
  return sum.apply(this, arguments);
}

function callSum2(num1, num2) {
  return sum.apply(this, [num1, num2]);
}

console.log(callSum1(10, 10)); // 20
console.log(callSum2(10, 10)); // 20
```

注意：严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window，除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined

call()方法和 apply()的作用一样，只是传参的形式不同

apply()和 call()主要作用是控制函数调用上下文即函数体内 this 值的能力

```js
window.color = "red";
let o = {
  color: "blue",
};

function sayColor() {
  console.log(this.color);
}

sayColor(); // red

sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
```

bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind()的对象

```js
window.color = "red";
var o = {
  color: "blue",
};
function sayColor() {
  console.log(this.color);
}

let objectSayColor = sayColor.bind(o); // 在o对象上创建了一个新函数objectSayColor()
objectSayColor(); // blue
```

## 10.11 函数表达式

定义函数有两种方式：函数声明和函数表达式

1. 函数声明的关键特点是`函数声明提升`
2. 函数表达式看起来像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫做`匿名函数`(兰姆达函数)

```js
let functionName = function(arg0，arg1,arg2){
  // 函数体
}
```

## 10.12 递归

递归函数通常是一个函数通过名称调用自己

```js
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

## 10.13 尾调用优化

```js
function outerFunction() {
  return innerFunction(); // 尾调用
}
```

1. 执行到 outerFunction 函数体，第一个栈帧被推倒栈上
2. 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction
3. 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction 的返回值
4. 弹出 outerFunction 的栈帧
5. 执行到 innerFunction 函数体，栈帧被推倒栈上
6. 执行 innerFunction 函数体，计算返回值
7. 将 innerFunction 的栈帧单出栈外

### 10.13.1 尾调用优化

尾调用优化是确定外部栈帧真的没存在的必要了

1. 代码在严格模式下运行
2. 外部函数的返回值是对尾调用函数的调用
3. 尾调用函数返回后不需要执行额外的逻辑
4. 尾调用函数不是引用外部函数作用域中自由变量的闭包

### 10.13.2 尾调用优化的代码

可以把简单的递归函数转换为待优化的代码

```js
function fib(n){
  if(n< 2){
return n
  }
  return fib(n - 1) + fib(n-2)
}

console.log(fib(0)) // 0
console.log(fib(1)) // 1
console.log(fib(2)) // 1
...
fib(1000)
```

上面的代码不符合尾调用优化的条件
下面符合尾调用优化的实现方式

```js
"use strict";

// 基础框架
function fib(n) {
  return fibImp1(0, 1, n);
}

// 执行递归
function fibImp1(a, b, n) {
  if (n === 0) {
    return a;
  }
  return fibImp1(b, a + b, n - 1);
}
```

## 10.14 闭包

匿名函数经常被人误认为是闭包，闭包指的是那些<mark>引用了另一个函数作用域中变量的函数</mark>
