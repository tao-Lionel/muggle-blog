## 变量
var

1. var可以重复声明
2. 作用域：全局作用域和函数作用域

let：

1. 同一作用域下不能重复声明
2. 作用域：全局作用域和块级作用域`{}`

let 和 var 的比较

1. var 声明的变量只能是全局或者整个函数块的
2. let 允许声明在一个作用域限制在块级的变量、语句或者表达式（块级作用域）
3. let 不能重复声明
4. let 存在暂时性死区

const：

1. let 有的它也有
2. 初始化时必须赋值
3. 赋值后不能改变类型
### 暂时性死区
只要块级作用域中存在let / const 命令，那么他所声明的变量就绑定了这个区域，不受外界的影响
在代码块内，使用`let`/`const`声明变量之前，该变量都是不可用的，所以叫‘暂时性死区’
```javascript
let a = 1
let test = function(){
  console.log(a)
  a++
}
test() // 1
```
```javascript
let  a = 1
let test = function(){
  console.log(a) 
  let a = 2
  a++
}
test() // ReferenceError
// 原因：在同一个作用域中，不能在定义之前使用a
```
### 函数作用域和块级作用域
函数作用域：在js中定义一个函数，函数内部的变量只能在函数内部访问，同时它可以修改和影响外部变量。
块级作用域：变量在离开定义的块级代码后立即被收回，存在暂时性死区的特性

没有块级作用的缺点：
**内层变量覆盖外层变量**
```javascript
var tmp = new Date()
function f(){
  console.log(tmp)
  if(false){
    var tmp = 'h'
  }
}

f() // undefined
```
**循环的变量泄露为全局变量**
```javascript
for(var i = 0; i < 3; i++){}

console.log(i) // 3
```
### 变量提升和函数提升
函数声明存在提升，在js中函数声明高于一切，函数是贵族。
```javascript
fn() // fn
function fn(){
console.log('fn')
}
```
变量提升： js语言也是先编译再执行，再编译阶段就会先搜集所有的变量，提前声明变量
```javascript
console.log(a) // undefined 
// 因为var声明的变量存在变量提升，所以a会提取到上面进行声明, 
// 执行到console.log(a)的时候a已经声明了，但是还没有赋值

var a = 1
```
如果换成`let`就会出现暂时性死区（即声明之前不可使用）
### 题目
```javascript
var a = 1;
function b() {
  a = 10;
  return;
  function a() {}
}
b();
console.log(a); // 1
```
解析：因为函数提升的原因，导致a=10 失效
## 执行上下文
**全局执行上下文**：这是默认或者是基础的上下文，任何不在函数内部的代码都在全局上下文中，创建的时候会创建一个window对象（浏览器中），并且把this指向这个全局对象，一个程序只有一个全局上下文。
**函数执行上下文**：函数在调用的时候会创建函数执行上下文，每个函数都有自己的执行上下文，可以由任意多个执行上下文。
**eval函数执行上下文**：eval函数也会有自己的执行上下文

**执行栈**：js执行时，先往执行栈中压入一个全局的执行上下文，遇到函数调用时，再压入当前函数的执行上下文，采用后进先出（LIFO）的数据结构 。
## == 和 ===
**==**：会引发隐式类型转换
**===**：值和类型都必须相等
```javascript
let  b = 3
let  a = new Number(3)
b == a // true
b === a // false 
```
在比较相等性中，基础类型比较他们的值，而对象类型比较他们的引用，检查对象中是否具有对内存中相同位置的引用。比如
```javascript
console.log({age:1} === {age:1}) // false
console.log({age:1} == {age:1}) // false

let a = {age:1}
let b = a
console.log(a === b) // true
console.log(a == b) // true
```
### 为什么 [] == ![]
首先我们要知道 == 是怎么工作的

1. 如果有一个值是布尔值，那么比较相等性之前先把布尔值转换为数字类型，false转为0，true转为1
2. 如果有一个值是字符串，另一个值是数值，那么先把字符串转为数值
3. 如果一个值是对象，另一个值不是，那么先调用对象的valueOf()，如果得到的返回值不是基本类型，则基于返回值再调用toString() （这个过程就是ToPrimitive）
4. 如果两个操作数都是对象，那么比较他们是否指向同一个对象

**[ ] == ![ ]**
首先! 运算符比== 优先级高
! 后面的值转为boolean，即 ![] 变为 !Boolean([]) , 也就是 !true  也就是false
[ ] == false
满足上面第一条规则，即Number(false)，即0
[ ] == 0
满足上面第三条规则，调用[].valueOf()，返回[], 再调用[].toString()，返回 ''
'' == 0
满足上面第二条规则，即Number(''), 返回0，0==0，所以为true
[参考](https://segmentfault.com/a/1190000008594792)
## this、call、bind、apply、
### this
**this永远指向最后调用它的那个对象**
```javascript
var a = 'abc'
let obj = {
  a:'bbc',
  fn: function(){
    console.log(this.a) // abc
  }
}

let fn = obj.fn
fn() // 最后调用fn的是window(全局对象)
```
**箭头函数的this始终指向函数定义时的this，而非执行时的。**箭头函数中没有this绑定，必须查找作用域链来决定其值，如果箭头函数被非箭头函数包含，那么this绑定的是最近一层非箭头函数的this，否则this是undefined
```javascript
var name = 'windowName'

let obj = {
  name: 'objName',
  fn1: function(){
    console.log(this.name)
  },
  fn2:function(){
    setTimeout(()=>{
      this.fn1() // setTimeout中的this绑定的是fn2中的this
    },100)
  }
}

obj.fn2() // objName
```


### apply、bind、call的区别
apply和call 基本功能一样，只不过apply接受一个数组参数，call接收若干个参数
```javascript
let obj = {
  fn: function(x,y){
    return x+y
  }
}

let fn = obj.fn
fn.call(obj,1,2) // 3

fn.apply(obj,[1,2]) // 3
```
bind：返回一个新的函数，必须手动调用
```javascript
let obj = {
  fn: function(x,y){
    return x+y
  }
}

let fn = obj.fn
fn.bind(obj,1,2)() // 3
```
[手写call、bind、apply](https://www.yuque.com/wangtao-llk90/ger3g1/xwitg88kvsny2uez#Smr77)
## new的过程
```javascript
function new1(fn,...args){
  let obj = {} // 创建一个新的对象
  obj.__proto__ = Object.create(fn.prototype) // 新对象的__proto__指向函数的prototype(原型)
  let res = fn.apply(obj,args) // 改变函数的this指向,并获取函数的执行结果
  return typeof res === 'Object' ? res : obj // 如果执行结果返回一个对象，那么就返回这个对象，否则返回新创建的对象
  
}
```
[手写new](https://www.yuque.com/wangtao-llk90/ger3g1/xwitg88kvsny2uez#dwfNd)
## 闭包
函数A中还有函数B，函数B中调用了函数A中的变量，那么函数B就是函数A的闭包
```javascript
function foo(){
  let num = 0
  return ()=>{
    num++
    console.log(num)
  }
}

let f = foo()
f() // 1
f() // 2
```
## 跨域
跨域是因为浏览器的同源策略（即协议、IP、端口相同）导致的
## 原始类型(基本类型)
原始类型有六个：
number、string、boolean、null、undefined、symbo
原始类型存的都是值
null 不是对象，`typeof null === 'object'`其实是一个历史遗留问题
**对象类型和原始类型的区别？**

1. 原始类型存储的是值
2. 对象类型存储的是地址（指针），当我新建一个对象类型的复杂数据时，会在内存中开辟一个空间来存放这个复杂数据，但是我们需要找到这个空间，那么就需要一个对应的地址。
```javascript
const a = {} // a实际上是一个地址，指向内存中这个对象
```
**函数参数是对象的情况**
函数参数传递的是对象指针的副本
```javascript
// 首先 函数参数传递的是对象指针的副本
function test(person){
  // 此时 person 还是指向 p1 的对象
  person.age = 27
  // 但是 当我们给person赋值了一个新的对象，那么person 就有了一个新的地址，和p1 没关系了
  person = {
    name: '小a',
    age: 30
  }

  return person
}

let p1 = {
  name: '小b',
  age: 20
}

let person = test(p1)

console.log(p1) // {name: '小b', age: 27}
console.log(person) // {name: '小a', age: 30}

```
## 四则运算符
加法的特点

1. 运算中其中一方为字符串，那么另一方就会转换成字符串
2. 如果一方不是字符串或者数字，那么就会转换成数字或者字符串
```javascript
1 + '2' // '12'
true + true // 2
1 + [1,2,3] // '11,2,3'
```
除了加法的运算符，只要其中一个为数字，就把另一个也转为数字
```javascript
4 * [] // 0
4 * '2' // 8
'2' * '3' // 6   这样也是可以的
```
## 浅拷贝和深拷贝
`Object.assign()`和`...`展开运算符可以实现浅拷贝
`JSON.parse(JSON.stringify(object))`可以基本实现深拷贝，但是对函数、`undefined`、`symbol`等会忽略
[手写深拷贝](https://www.yuque.com/wangtao-llk90/ger3g1/xwitg88kvsny2uez#DhJ12)

## 浏览器 Event Loop
微任务（microtask）：`process.nextTick`、`promise`、`MutationObserver`
宏任务（macrotask）：`script`、`setTimeout`、`setInterval`、`setImmediate`、`I/O `，`UI rendering`

JS遇到异步任务时会被挂起，并在有需要的时候放到Task队列中，一旦执行栈为空，Event Loop就会从Taskd队列中拿出需要执行的代码并放入执行栈中

Event Loop执行顺序

1. 首先执行同步代码，这属于宏任务
2. 当执行完同步代码后，执行栈为空，查询是否有异步代码需要执行
3. 执行所有的微任务
4. 执行完微任务后，如有必要会渲染页面
5. 然后开始下一轮Event Loop

**下面代码输出的顺序是什么？**
```javascript
console.log('script start')

async function async1(){
  await async2()
  console.log('async1 end')
}

async function async2(){
  console.log('async2 end')
}

async1()

setTimeout(()=>{
  console.log('setTimeout end')
},0)

new Promise((resolve)=>{
  console.log('Promise end')
  resolve()
}).then(()=>{
  console.log('Promise then1')
}).then(()=>{
  console.log('Promise then2')
})

console.log('script end')

```
